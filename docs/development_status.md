# AI駆動プロジェクト実行システム - 開発状況

最終更新: 2025-06-12（共有コンテキスト機能の完全実装）

## 概要

WBS（Work Breakdown Structure）を基にしたAI駆動のプロジェクト自動実行システムの開発状況をまとめます。

## 実装済み機能

### 1. コアシステム

#### TaskGraphEngine (`src/core/task_graph_engine.py`)
- ✅ WBS YAMLファイルの読み込み
- ✅ タスクの依存関係解決（トポロジカルソート）
- ✅ 循環依存の検出
- ✅ 実行可能タスクの動的取得
- ✅ タスクステータス管理（PENDING, IN_PROGRESS, COMPLETED, FAILED）

#### TaskExecutor (`src/core/task_executor.py`)
- ✅ Claude Code（`claude --print`）を使用したタスク実行
- ✅ 非同期並列実行（セマフォによる同時実行数制御）
- ✅ タイムアウト処理
- ✅ 作業ディレクトリの分離
- ✅ `.claude/settings.json`によるWriteツール許可
- ✅ 成果物の収集

#### Orchestrator (`src/core/orchestrator.py`)
- ✅ プロジェクト全体の実行管理
- ✅ 並列実行可能なタスクの同時実行
- ✅ 実行状態の永続化と復元
- ✅ プログレスコールバック
- ✅ ドライランモード
- ✅ fail-fastオプション

### 2. 成果物管理

#### ArtifactManager (`src/core/artifact_manager.py`)
- ✅ タスク成果物の自動記録
- ✅ ファイルメタデータ管理（ハッシュ、サイズ、タイムスタンプ）
- ✅ ファイル競合の検出
- ✅ 成果物レジストリの永続化（JSON）
- ✅ ファイル名からタスクの逆引き
- ✅ **共有ワークスペース管理**（2025-06-12追加）
- ✅ **スナップショットによる変更検出**（2025-06-12追加）
- ✅ **タスク結果の自動統合**（2025-06-12追加）

#### ConflictResolver (`src/core/conflict_resolver.py`)
- ✅ Claude Codeを使用した自動マージ
- ✅ マージ不可能な場合の自動バージョニング
- ✅ マージ結果の品質確認
- ✅ **3-wayマージのサポート**（2025-06-12追加）

### 3. WBS自動生成

#### WBSGenerator (`src/core/wbs_generator.py`)
- ✅ 要求文からのWBS自動生成
- ✅ Claude Codeによる適切なタスク分解
- ✅ 依存関係の自動設定

### 4. CLIインターフェース

#### run_project (`src/cli/run_project.py`)
- ✅ プロジェクト実行コマンド
- ✅ リッチな進捗表示（プログレスバー）
- ✅ ドライランモード
- ✅ 状態ファイルによる再開機能

#### generate_wbs (`src/cli/generate_wbs.py`)
- ✅ WBS生成コマンド
- ✅ 出力先指定オプション
- ✅ 作業ディレクトリのクリーンアップ

## テスト

- ✅ 単体テスト（30テスト）
  - TaskGraphEngine: 10テスト
  - TaskExecutor: 7テスト
  - Orchestrator: 5テスト
  - ArtifactManager: 8テスト
  - ArtifactIntegration: 3テスト（非同期対応）

## 最新の実装（2025-06-12）

### 共有コンテキスト機能の完全実装

#### 背景と問題
従来のシステムでは、各タスクが独立したワークスペースで実行されるため、以下の問題がありました：
- タスク間でファイルをimportできない
- 前のタスクが作成したファイルを参照できない
- インクリメンタルな開発ができない

#### 実装した解決策

##### 1. Copy-on-Write方式による共有ワークスペース
```
初期状態:
  shared/ (空)

タスク1実行:
  1. shared/ を task_1/ にコピー（空なので新規作成）
  2. task_1/ で作業（models.py作成）
  3. 完了後、変更を shared/ に統合
  
タスク2実行:
  1. shared/ を task_2/ にコピー（models.pyを含む）
  2. task_2/ で作業（models.pyを参照してmain.py作成）
  3. 完了後、変更を shared/ に統合
```

##### 2. スナップショット機能
- **実装内容**:
  - タスク開始時にディレクトリ状態を記録
  - 各ファイルのSHA256ハッシュ値を計算
  - ファイルメタデータ（サイズ、更新時刻）も保存
  
- **変更検出**:
  - 新規ファイル: 開始時に存在せず、終了時に存在
  - 変更ファイル: ハッシュ値が異なる
  - 削除ファイル: 開始時に存在し、終了時に存在しない

##### 3. 3-wayマージによる競合解決

**重要な発見：コンフリクトの考え方**

###### 依存関係がある場合（順次更新）
```yaml
- id: task-a
  prompt: "ファイルを作成して値を'A'に設定"
  
- id: task-b
  depends_on: [task-a]
  prompt: "値を'A'から'B'に変更"  # task-aの結果を見て作業
```
→ **コンフリクトは発生しない**（期待通りの動作）

###### 依存関係がない場合（並列更新）
```yaml
- id: task-a
  depends_on: [create-file]
  prompt: "2行目を'Universe'に変更"
  
- id: task-b
  depends_on: [create-file]  # task-aには依存しない
  prompt: "2行目を'Galaxy'に変更"
```
→ **コンフリクトが発生**（3-wayマージで解決を試みる）

###### 3-wayマージの仕組み
```
BASE（開始時点）:    Line 2: World
SHARED（共有）:      Line 2: Universe （task-aの変更）
TASK（タスク結果）:  Line 2: Galaxy   （task-bの変更）

結果: CANNOT_MERGE.txt を作成（自動解決不可）
```

##### 4. 統合フロー
1. **タスク開始時**:
   - 共有ワークスペースをタスク用ディレクトリにコピー
   - .claude/settings.jsonもコピー（ツール権限を維持）
   - スナップショットを作成

2. **タスク実行中**:
   - タスクは共有ワークスペースの最新状態で作業
   - 他のタスクが作成したファイルを参照可能

3. **タスク完了時**:
   - 変更を検出（新規/変更/削除）
   - 共有ワークスペースに統合
   - 競合があれば3-wayマージを実行

##### 5. 重要な実装詳細

###### .claude/settings.jsonの扱い
```json
{
  "permissions": {
    "allow": [
      "Write",
      "Edit",
      "Read"
    ]
  }
}
```
- 各タスクワークスペースにコピーすることで、Claude Codeがファイル操作可能に

###### リファクタリング：共有コンテキストの常時有効化
- 当初は`shared_context`設定のオン/オフを想定
- 実装後、常に有効にすべきと判断
- 不要な分岐を削除してコードを簡潔に

### テスト結果と検証

#### 1. 順次更新テスト（成功）
```
タスク1: Count: 0 → Count: 1
タスク2: Count: 1 → Count: 2 （タスク1の結果を基に）
タスク3: Count: 2 → Count: 3 （タスク2の結果を基に）
結果: 全て成功、コンフリクトなし
```

#### 2. 並列更新テスト（期待通りのコンフリクト）
```
タスク1: Line 2: World → Universe
タスク2: Line 2: World → Galaxy （並列実行）
結果: 3-wayマージ失敗、CANNOT_MERGE.txt作成
```

### 設定方法
```yaml
# 設定不要 - 共有コンテキストは常に有効
# 以下は削除済み：
# execution:
#   shared_context: true
```

## 実装していない機能

### 1. エラーリカバリ
- ❌ 失敗したタスクの再試行メカニズム
- ❌ 部分的な成功の処理
- 現状：fail-fastまたは続行のみ

### 3. 実行最適化
- ❌ タスクの実行時間予測
- ❌ リソース使用量に基づく並列度の動的調整
- ❌ キャッシュメカニズム

### 4. UI/UX
- ❌ WebUI
- ❌ 対話的なWBS編集
- ❌ 実行状況のリアルタイムモニタリング（Web）

## 検討が必要な事項

### 1. WBS生成の品質向上
- **タスク粒度の標準化**
  - 1タスク = 1ファイル？
  - 1タスク = 1機能？
  - 時間ベース（30分程度のタスク）？

- **プロンプトフォーマットの統一**
  - 自然言語 vs 構造化された指示
  - 成果物の明示的な指定
  - テスト可能な完了条件

### 2. ~~共有コンテキストの実装方針~~ ✅ Copy-on-Write方式で実装済み

### 3. スケーラビリティ
- 大規模プロジェクト（100+タスク）への対応
- 実行ログの管理
- 成果物ストレージの最適化

### 4. 品質保証
- 生成されたコードの自動テスト
- リンター/フォーマッターの統合
- セキュリティチェック

### 5. テンプレート/パターン
- よくあるプロジェクトタイプのテンプレート化
- カスタムタスクタイプの定義
- 再利用可能なタスクライブラリ

## 次のステップの提案

1. **短期的改善**
   - ~~共有コンテキストの基本実装~~ ✅ 完了
   - WBS生成プロンプトの改善
   - エラーメッセージの改善
   - ベースファイル保存機能の実装（3-wayマージの完全対応）

2. **中期的目標**
   - WebUIの実装
   - テンプレートシステム
   - より高度な競合解決

3. **長期的ビジョン**
   - プラグインシステム
   - 他のAIモデルのサポート
   - エンタープライズ機能（権限管理、監査ログ等）

## 既知の問題

1. ~~**import問題**: タスクが独立実行されるため、生成されたファイル間でimportができない~~ ✅ 共有コンテキスト機能で解決
2. **タイムアウト**: 大きなタスクやマージ処理に時間がかかる場合がある
3. **Claude Codeの制限**: `--print`オプションでは`-f`（ファイル参照）が使えない
4. **ベースファイルの保存**: 現在の実装では3-wayマージ時のベースファイル内容が保存されていない（簡易実装）

## 成功事例

1. **FastAPI CRUDアプリ生成**: 基本的なAPIは正常に生成可能
2. **ファイル競合の自動解決**: Claude Codeによるインテリジェントなマージ成功
3. **並列実行**: 依存関係のないタスクの効率的な並列実行
4. **インクリメンタル開発**: 共有コンテキストにより、前のタスクの成果物を基に次のタスクが作業可能（2025-06-12）
5. **順次更新の成功**: カウンターの例で、4つのタスクが順番に値を更新（0→1→2→3）（2025-06-12）

## まとめ

基本的なシステムは完成し、動作確認も取れています。**2025-06-12のアップデートで共有コンテキスト機能が実装され、タスク間でのファイル参照とインクリメンタルな開発が可能になりました。** 今後は実用性を高めるための改善（特にWBS品質とエラーハンドリング）が主な課題となります。